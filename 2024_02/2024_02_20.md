# 2024.02.19 TIL

## 📚 JavaScript

## 변수 다루기

### 🚨 var를 지양하자

let 과 const는 ES2015 버전부터 생긴 것이기 때문에 그 이전에는 어쩔 수 없이 var 예약어를 통해서만 변수를 만들수가 있었는데

자바스크립트가 발전을 하면서 더 좋은 기능들이 추가된 것이고 let과 const는 그 좋은 기능들에 대한 예시다.

### 👋let과 const를 왜쓰는건데?

#### var는 함수 스코프 그리고 let과 const는 블록 단위 스코프를 가지게 된다.

JavaScript에서 var, let, const로 선언된 변수는 사실 호이스팅이 다 발생한다.(함수도 됨)

하지만 var와는 다르게 let과 const는 **Temporal Dead Zone (TDZ)** 라는 개념 때문에 선언 전에 접근하려고 하면 ReferenceError가 발생한다.

```js
console.log(x); // ReferenceError: x is not defined
let x = 5;
console.log(x); // 5
```

이는 let과 const 선언이 TDZ에 들어가자마자 시작되고, 초기화(할당)가 이루어지기 전까지는 그 지점에서 변수에 접근할 수 없게된다.<br>
TDZ의 도입으로 인해 코드의 안정성을 높이고 잠재적인 버그를 쉽게 찾을 수 있다.

---

### ❗️Scope

#### ⚡️블록 scope

주어진 코드 블록 ({ })안에서만 사용이 가능하며 밖에서는 접근할 수 없음을 의미한다. 함수, if문, for문, while문, try/catch문 등에서 사용되는 let과 const는 해당 블록 내부에서만 사용이 가능하다.

그렇기 때문에 다른 외부에서는 접근을 할 수 없다.

#### ⚡️함수 scope

var로 선언된 변수는 함수 스코프 또는 전역 스코프를 가진다.

1. 함수 스코프<br>
   var로 선언된 변수는 선언된 함수 내에서만 접근 가능하다. 함수 외부에서는 해당 변수에 접근할 수 없다.

```js
function testFunc() {
  var x = "hello";
  console.log(x); // 'hello'
}
testFunc();
console.log(x); // ReferenceError: x is not defined
```

2. 전역 스코프<br>
   함수 외부에서 var로 선언된 변수는 전역 변수가 되며, 코드의 어디에서나 접근할 수 있다.

```js
var x = "hello";
console.log(x); // 'hello'
```

하지만 var로 선언된 변수는 블록 스코프를 무시하므로 if문, for문 등의 중괄호 {}내에서 var로 선언된 변수는 블록 외부에서도 접근할 수 있다.

```js
if (true) {
  var x = "hello";
}
console.log(x); // 'hello'
```

---

### 🚨전역 공간 사용 최소화

전역 공간이 무엇일까? 라는것에 대해 중요성이 하나 있어야 한다.

전역공간은 window와 global로 나뉜다. 그 이유가 무엇이냐면

**브라우저 환경에서 돌아가는 경우에는 window가 최상위, node.js 환경에서는 global이 최상위**다.

크게 다른건 없다.

전역공간은 바로 최상위다.
그리고 최상위를 나눌 때 보통은 브라우저 환경이랑 Node.js 환경이 있구나 알면 된다.

### ❗️전역 공간을 최소화해야 하는 이유

#### 1. 네임스페이스 충돌 방지

전역 변수나 함수를 과도하게 사용하면 다른 라이브러리나 코드와의 충돌이 발생할 수 있어 예상치 못한 동작이 발생하거나 프로그램이 오동작할 수 있다.

#### 2. 코드 유지보수 용이성

전역 변수를 사용하면 코드의 의존성이 숨겨질 수 있다.

#### 3. 성능 개선

전역 변수는 전체 애플리케이션의 메모리를 차지하므로 메모리 소비를 증가시킬 수 있다. 또한 전역 변수에 대한 접근이 지역 변수보다 느릴 수 있다. 지역 변수를 사용하면 메모리 사용량을 최적화하고 성능을 향상시킬 수 있다.

---

JavaScript에서 window 객체는 전역 객체이며, 브라우저 환경에서는 기본적으로 제공된다. window 객체는 브라우저 창을 나타내며, 전역 스코프에서 접근할 수 있는 다양한 기능과 속성을 제공한다. 그러나 대부분의 경우 window 키워드를 생략하고 그냥 함수나 속성을 호출하는 것이 일반적이다.

---

### 🚨 호이스팅 주의하기

호이스팅은 JavaScript에서 변수 및 함수의 선언이 스코프의 맨 위로 끌어올려지는 것을 말한다. 이것은 코드의 실행 전에 이루어지는 과정으로, 코드 실행 도중에 일어나는 것이 아니다.

#### ⚡️런타임 시기에 선언과 할당이 분리됨

변수 선언의 경우, 해당 변수가 선언된 스코프의 맨 위로 끌어올려지지만 할당은 그대로 남아있다. 즉 변수의 초기화는 호이스팅 되지 않는다.

함수 선언 또한 호이스팅된다. 즉, 함수가 선언된 위치와 상관없이 해당 스코프의 맨 위로 끌어올려진다. 이것은 함수 표현식과는 달리 함수 선언문에만 해당된다.

호이스팅은 코드를 작성할 때 주의해야할 점 중 하나다. 변수나 함수를 사용하기 전에 선언해야 한다는 규칙을 염두에 두고 코드를 작성해야 한다.

---

### ❗️호이스팅은 왜 일어나는거야?

호이스팅은 JavaScript 엔진이 코드를 처리하는 방식에 기인한 특징이다. JavaScript 엔진은 코드를 두 번째 단게에서 실행하기 전에 컴파일하고 이 과정에서 변수와 함수 선언을 메모리에 저장하고 코드 실행 전 이들을 처리하는 것이 호이스팅이다.

호이스팅이 발생하는 이유는 JavaScript의 구문적인 유연성과 일관성을 위함인데 코드의 어디서든 변수나 함수를 선언할 수 있도록 하면서도, 이들을 사용하기 전에 **선언되었는지 확인하여 예기치 않은 동작을 방지**할 수 있다.

---

### ❗️함수 선언식과 함수 표현식

JavaScript에서 함수를 생성하는 두 가지 주요 방법인 함수 선언식과 함수 표현식의 주요 차이점을 살펴보자

1. 호이스팅<br>
   함수 선언식은 호이스팅에 영향을 받는다. 즉, 함수 선언식으로 선언된 함수는 선언 전에 호출할 수 있다. 반면 함수 표현식은 호이스팅에 영향을 받지 않는다. 함수 표현식으로 선언된 함수는 선언 이후에만 호출할 수 있다.

```js
// 함수 선언식
console.log(add(1, 2)); // 3
function add(a, b) {
  return a + b;
}

// 함수 표현식
console.log(subtract(2, 1)); // TypeError: subtract is not a function
var subtract = function (a, b) {
  return a - b;
};
console.log(subtract(2, 1)); // 1
```

2. 익명성<br>
   함수 선언식은 항상 함수 이름을 가진다. 반면 함수 표현식은 이름이 없는 익명 함수를 사용할 수 있다. 익명 함수는 디버깅할 때 어려움을 초래할 수 있지만, 즉시 실해 함수 표현식(IIFE)등의 패텬에서 유용하게 사용된다.

```js
// 함수 선언식
function add(a, b) {
  return a + b;
}

// 함수 표현식 (익명 함수)
var subtract = function (a, b) {
  return a - b;
};
```

함수를 만들 때 함수 표현식으로 만드는 것을 추천한다.<br>
그 이유는 함수 표현식은 호이스팅에 영향을 받지 않으므로 코드의 예측 가능성을 높이고 버그를 줄이는 데 도움이 되고 클로저를 생성하여 함수를 실행하기 전에 해당 함수에 변수를 넘기고 싶을 때 사용할 수 있다.

#### 💡클로저

JavScript에서 중요한 개념으로 내부 함수가 외부 함수의 맥락에 접근할 수 있는 것을 가리킨다.

#### 클로저의 장점

1. 데이터 보존
2. 정보의 접근 제한(캡슐화)
3. 모듈화에 유리

---

## 타입 다루기

### 🚨 타입 검사

### ❗️typeof 연산자

typeof는 문자열로 반환하는 것이 특징이다.

그런데 하나의 단점이 있다.<br>
타입을 검사할 때 결국 모든게 typeof로 커버가 되는게 아닌가 생각할 수 있지만 그렇지 않다.

그 이유는 자바스크립트의 타입을 크게 분류해보자면 원시값(primitive)과 객체형(reference)가 있다.

string, boolean, undefined, number, symbol은 대부분 원시값이고 때문에 불변하다. 하지만 reference 계열은 object인데 굉장히 많은 값들이 있다. Array, function, Date 등.. 이것들은 typeof로 간별해 내기가 굉장히 어렵다.

한번 함수에 대해 검사해보자.

```js
function myFunction() {}

console.log(typeof myFunction); // function
```

```js
class myClass {}

console.log(typeof myClass); // function
```

class도 함수로 나온다. 굉장히 많은것들을 이용할 수 없다. 그래서 위험하게 볼 수 있다.

```js
const str = new String("문자열");
console.log(typeof str); // object
```

primitive 값들은 typeof 연산자로 검사를 잘 할 수 있지만 reference 값들은 어렵다. 그래서 "typeof가 만능은 아니다" 라는걸 알아야 한다.

#### ⚡️typeof null은 객체라고 뜬다.

이것은 자바스크립트에서 인정한 것인데 오류가 맞다. 언어적인 오류이고 자바스크립트가 발전해오면서 수정할 수 없다고 판단하여 수정하지 않고 있다.

#### 자바스크립트는 동적으로 변하는 언어이기 때문에 타입까지 동적이다. 따라서 타입을 검사할 때 굉장히 많은 주의를 해주어야 한다.

---

### ❗️instanceof 연산자

이 연산자는 객체가 특정 클래스의 인스턴스인지 확인하는 데 사용된다. 이 연산자는 객체의 프로토타입 체인을 따라 올라가며 지정된 클래스의 프로토타입을 찾는다. 만약 찾는다면 true, 아니라면 false를 반환한다.

---

### 🚨 undefined & null

![alt text](./img/image41.png)

```js
!null; // true
!!null; // false

null === false; // false
!null === true; // true
```

null은 수학적으로 0으로 취급된다. 비어있는 값을 명시적으로 지정하는 방법이지만 숫자적으로 표현할때는 0에 가깝다.

```js
let varb;
typeof varb; // undefined
```

변수를 선언했지만 값을 선언하지 않으면 이렇게 undefined가 뜬다.
선언했지만 값은 정의되지 않고 할당 되지 않으면 undefined라고 한다.

undefined + 10은 NaN이다.

null은 0이라는 숫자로 표현이 되지만 undefined는 NaN으로 표현이 된다.

!undefined는 true가 나온다.
undefined == null은 true다.

#### 정리

undefined, null -> 값이 없거나 정의가 되지 않은 것. null같은 경우엔 명시적으로 값이 없는것을 명시적으로 표현한 것이다. null은 숫자로 표현했을 때 0에 가깝도 undefined는 NaN에 가깝다. type으로 봤을 때는 undefined는 undefined고, null은 object다.

---

### 🚨 eqeq 줄이기 (eqeqeq 사용하기)

예를들어 ticketNum 이라는 변수가 있다고 쳐보자.

```js
ticketNum.value; // "0"
ticketNum.value === 0;
false;
// 위 결과가 나오면 우리는 이러한 시도를 한다.
ticketNum.value == 0;
```

하지만 이런 느슨한 동등연산자를 역이용하는 것은 팀원들 관점에서 봤을땐 좋지 못하다. 어떠한 오류를 불러올지 모르기 때문이다. 위험하다.

어떻게든 형 변환을 수동으로 해서 엄격한 동등연산자로 비교하는 것을 추천한다.

```js
Number(ticketNum.value) === 0;
```

이런식으로 안전하게 검사를 해야한다.

---

### 🚨 형변환 주의하기

```js
"1" == 1;
1 == true;
0 == false;
```

이 코드는 사람이 봤을 떄 느슨한 검사를 하는구나 라고 생각할 수 있지만 결국에 형 변환이 일어나고 있다고 보면된다.(암묵적 형변환)

```js
11 + "문자와 결합"; // "11 문자와 결합"
!!"문자열"; // true
```

따라서 명시적으로 변환을 하자.

```js
String(11 + "문자와 결합");
Boolean("문자열");
```

#### 결론

JavaScript를 활용하는데 있어서 사용자가 형변환을 했을 때는 명시적인 형변환이라고 보면 된다.

사용자가 아니라 자바스크립트 엔진이 평가했을 때 암묵적인 형변환이 일어날 수 있다.

떄문에 타입을 변환할 때 명시적으로 형변환을 해서 예측하기 쉬운 타입 변환을 활용하는 것을 추천한다.

#### Number(), String()은 명시적 형변환을 수행한다.

---

### 🚨isNaN

기존의 isNaN() 함수는 값이 NaN인지 확인할 때 값이 숫자인지 여부를 먼저 확인한다. 따라서 문자열이나 객체 등의 값도 숫자로 변환하여 NaN 여부를 판단한다. 이 때문에 예상치 못한 결과를 가져올 수 있다.

하지만 Number.isNaN() 함수는 값이 NaN인지를 엄격하게 판단한다. 즉 값이 NaN이면 true를 반환하고, 그렇지 않으면 false를 반환한다.

```js
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN(123)); // false
console.log(Number.isNaN("hello")); // false
console.log(Number.isNaN(undefined)); // false
```

---
