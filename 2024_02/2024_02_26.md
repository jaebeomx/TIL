# 2024.02.26 TIL

JavaScript의 소수점 버리기
프로그래머스 코딩테스트 문제를 풀던 중 숫자를 소수점 이하에서 버리고 정수 부분만 남기는 문제를 JavaScript의 Math.floor()를 이용하지 않고도 얻을 수 있는 방법이 있어 소개하려 한다.

(단, 이 접근 방식은 코드의 가독성을 해치고 의도를 명확히 전달하지 않을 수 있으므로 주의해서 사용해야 한다.)

( ~ )
' ~ ' 는 비트 NOT 연산자로 피연산자의 각 비트를 반전시킨다. 이 연산자는 피연산자를 2의 보수로 변환하여 비트를 반전시킨다.

예를들어, 8비트 이진수 101010을 NOT 연산하면 각 비트가 반전된다.

(~가 틸드 연산자로 불리는 이유는 물결을 뜻하는 영어식 표현이라고 한다)

10101010 (원래 수)
01010101 (NOT 연산 결과)
이진수에서 각 비트는 0 또는 1의 값을 가지며, NOT 연산은 0을 1로, 1을 0으로 변경한다.

JavaScript의 틸드연산자(~)는 비트 NOT 연산자를 수행하는데 이 연산자는 32비트 정수로 변환한 후 각 비트를 반전시킨다.

JavaScript의 숫자 표현 방식
JavaScript에서는 정수와 실수를 따로 구분하지 않고, 모든 수를 실수 하나로만 표현한다.

자바스크립트에서 모든 숫자는 IEEE 754 국제 표준에서 정의한 64비트 부동 소수점 수로 저장되는데

비트연산자를 사용할 때는 이러한 64비트 부동소수점 수를 32비트 정수로 변환하여 연산을 수행한다.
(이는 비트연산자가 정수에 대해서만 동작하기 때문)

따라서 JavaScript에서는 일반적으로 숫자를 64비트 부동소수점 형식으로 표현하지만, 비트 연산을 수행할 때는 32비트 정수로 변환하여 연산을 수행한다.

~~ 연산자 (두 개의 비트 NOT 연산자)
비트 NOT 연산자를 두 번 적용하면 원래의 수가 되는데, 왜냐하면 모든 비트가 두 번 반전되기 때문이다.

그러나 중요한 점은 이 과정에서 피연산자가 32비트 정수로 변환된다는 것이다.

이렇게 변환된 값은 소수부를 완전히 제거하고(32비트 정수니까) 소숫점 이하의 숫자는 버려진다.

그래서 결과적으로 소수점 이하가 있는 수를 내림하여 가장 가까운 작은 정수로 변환할 수 있다.

따라서 ~~연산자는 피연산자를 피연산자의 소수점 이하의 부분을 제거하는 효과를 보여준다.

~~3.14 -> 3 // 양수도 3을 반환
~~-3.14 -> 3 // 음수도 3을 반환
말그대로 소수부를 제거하는 역할을 하기 때문에 양수 3.14도 ~~를 적용하면 3을 반환하고, 음수 3.14도 ~~를 적용하면 3을 반환한다.

// Math.floor() 함수는 가장 가까운 더 적은 정수를 반환
Math.floor(3.14); // 3
Math.floor(-3.14); // -4

// Math.ceil() 함수는 주어진 숫자와 같거나 가장 가까운 더 큰 정수를 반환
Math.ceil(3.14); // 4
Math.ceil(-3.14); // -3

쉽게 말하자면 Math.floor()은 숫자를 내림하고, Math.ceil()은 숫자를 올림하는 역할을 한다.

소수점을 버리는 것을 목적으로 두는지, 반올림 하는것을 목적으로 두는지, 반내림 하는것을 목적으로 두는지에 따라 어떤 연산자를 사용해야 할지 잘 결정을 해야한다.

JavaScript의 Math 메소드를 놔두고 ~~를 사용하는 이유?
일반적으로 ~, ~~ 연산자는 Math.floor()이나 Math.ceil() 함수보다 빠르게 동작한다. 이는 ~~ 연산자가 비트 연산을 직접 수행하기 때문이다.

비트 연산은 컴퓨터 하드웨어에서 직접 지원되므로 매우 빠르게 수행되므로 매우 빠르게 수행되는 반면 Math.floor() 함수는 상대적으로 더 복잡한 연산을 수행하므로 느릴 수 있다.

(솔직히 얼마나 차이나겠나 싶음..)

결론
그래서 내 개인적인 생각으로는 틸드 연산자는 그냥 코테문제 풀때나 쓰고, 협업을 위한 코드를 작성할 때는 가독성 있는 코드를 작성하는게 더 좋을것 같다는 결론이다.
